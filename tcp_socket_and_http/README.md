## TCP Socket and HTTP

### プロトコルとレイヤー

Goでは`http`、``tcp`、`udp` についての組込機能が提供されている。

### HTTPとその上のプロトコル

#### HTTPの基本

HTTPでは、クライアントからのリクエストと、
それに対するサーバのレスポンスが規定されている。

```
メソッド パス HTTP/1.0
ヘッダ1: ヘッダーの値
ヘッダ2: ヘッダーの値
(空行)
リクエストボディ（あれば）
```

改行を区切り文字と決めている。

リクエスを受け取ると、以下の形式のレスポンスとして返す。

```
HTTP/1.0 200 OK
ヘッダ1: ヘッダーの値
ヘッダ2: ヘッダーの値
(空行)
サーバレスポンス
```

用途が広がったことでHTTPに対して要求される機能も増えた。
HTTP/2では通信内容がバイナリ化されて高速化。

#### RPC

RPC(Remote Procedure Calling)は、サーバが用意している機能を、
ローカルコンピュータ上にある関数のように簡単に呼び出そうとする仕組み。

- XML-RPC
- JSON-RPC

JSON-RPCの例

```
// 送信側
{"jsonrpc": "2.0", "method": "subtract", "params": [42, 23], "id": 1}
// 受信側
{"jsonrpc": "2.0", "result": 19, "id": 1}
```

#### REST

すべてを階層化されたリソース(ファイルのようなもの)とみなし、
URLを使ってそれらのリソースを取得したり投稿したりする。
このような考え方は、REST(Representational State Transfer)と呼ばれる。

RESTはHTTPのルールを最大限取り入れたプロトコル。
RESTの思想にしたがうシステムのことをRESTful。
HTTPレスポンスに`link`を入れ、そこからクライアントが自律的にデータ探索をし、リソースにアクセスする仕組みを`HATEOAS`。

HATEOASの原則に従ったAPI（例 github)。

#### GraphQL

Facabookが提唱するRPCベースのプロトコル。
GraphQLは複数の属性から構成されている要素を取得するためのクエリー言語。

### ソケットとは

ほとんどのOSではアプリケーション層からトランスポート層のプロトコルを利用するとき、
APIとしてソケットを利用

ブラウザを利用したHTTP通信は、サーバのTCPポート80番に対し、ソケットを使ったプロセス間通信を行います。

### ソケット通信の基本構造

net.Connを使って、HTTPによる通信。
Goの場合、サーバは`Listen()`、クライアントは`Dial()`というAPIの命名ルールがある。

クライアント

```golang
conn, err := net.Dial("tcp", "localhost:8080")
if err != nil {
  panic(err)
}
```

サーバー側

```golang
ln, err := net.Listen("tcp", ":8080")
if err != nil {
  panic(err)
}
conn, err := ln.Accept()
if err != nil {
  // handle error
}
```

1つのリクエストの処理中も他のリクエストを受け付けたり、
CPUが許す限り並列でタスクをこなしたりするためには

```golang
ln, err := net.Listen("tcp", ":8080")
if err != nil {
  panic(err)
}
// 一度で終了しないためにAccept()を何度も繰り返し呼ぶ
for {
  conn, err := ln.Accept()
  if err != nil {
    // handle error
  }
  // 1リクエスト処理中に他のリクエストのAccept()が行えるように
  // Goroutineを使って非同期にレスポンスを処理する
  go func() {
    // connを使った読み書き
  }()
}
```

#### Go言語でHTTPサーバを実装する

実際にGo言語でHTTPのコードを作成するときは、net/http以下のAPIを使う。

HTTP/1.1のKeep-Aliveに対応させる。
HTTP/1.1ではKeep-Aliveが規格に入った。
HTTP/1.0のように1つのメッセージごとに切断するのではなく、しばらくの間はTCP接続のセッションを維持して使いまわせる。

```
 Keep-Aliveを使うことで、HTTP/1.0のように1つのメッセージごとに切断するのではなく、しばらくの間はTCP接続のセッションを維持して使いまわします。 TCPでは、セッションを接続するのに1.5 RTT（ラウンドトリップタイム：1往復の通信で1RTT）の時間がかかります。切断にも1.5 RTTの時間がかかります。 物理的な距離や回線速度などで1 RTTの時間は変わりますが、RTTが多ければ通信速度に直接の影響を与えます。 一度の送信（送信と確認の返信で1 RTT）につき1.5 + 1.5 = 3 RTTのオーバーヘッドがあれば、実行速度は単純に1/4です。
 ```

 #### 圧縮

 圧縮をしてもパケット伝達の速度は変わらない。
 転送を開始してから終了するまでの時間は短くなる。

 #### チャンク形式のボディ

 必要な情報をすべて一回で送ると全部のデータが用意できるまでレスポンスのスタートが遅れる。
 巨大なファイルを返すときに全体がメモリにロードされ、多大なリソースが必要。
 httpではチャンク形式のレスポンスをサポートすることで、これらの問題に対処している。

 チャンク形式ではヘッダーに送信データのサイズを書かずに、`Transfer-Encoding: chunked`というヘッダーを付与。
 チャンク形式であれば、準備ができた部分からレスポンスを開始できるため、レスポンスの初動が早くなる。
 データ全体を保持のためにメモリを確保するオーバーヘッドも減らせる。 
 ヘッダーにサイズを入れる必要もなく、最終的なデータのサイズが決まる前に送信を開始可能。
 