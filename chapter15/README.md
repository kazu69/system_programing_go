## Go言語のメモリ管理

### カーネル

プロセスはメモリを読み書きするのに物理的なアドレスを直接使わずに、仮想的なメモリアドレスにアクセスする。
メモリ管理ユニット(MMU)が管理している。

仮想メモリアドレスから実際の物理アドレス上のデータへのアクセスには、ページテーブルと呼ばれる階層型のデータ構造が使われる。

メモリ全体は4KBずつのページに分けられる。
物理的な保存領域が細切れになっていても、プロセスからは4GBのフラットなメモリ領域に見える。

ページテーブルへの変換は変換テーブルをキャッシュする仕組みがあるため遅延は考慮しない。
キャッシュはTLB(Translation Lookaside Buffer)と呼ばれる

### メモリ空間

プロセスは起動時にOSからメモリをもらい、 OSはプロセスごとに仮想メモリの領域確保。

ユーザーのメモリ空間は大きく3つの連続したメモリ領域に分かれる。
メモリ番号の若い方番地から

- プログラム、プログラムの静的変数
- 共有ライブラリ
- スタックメモリ
- カーネル

Go言語ではスタックメモリの管理は独自に行っているため、上記には一致しない。

ちなみにプロセスのメモリ未割り当て領域はヒープ。
ヒープ上の未割り当てメモリの先頭アドレスをブレーク値という。

### システムコール

POSIX系OSでメモリブロックの確保に使うシステムコール。


- mmap

ファイルをメモリにマップする。
ファイルを指定しない場合は、指定サイズのメモリを確保する。

- brk

ヒープ領域のブレーク値を変更。
指定したブレーク値が現在のブレーク値より大きい場合には、ヒープ領域にメモリを割り当て。
指定したブレーク値が現在のブレーク値より小さい場合には、ヒープ領域に動的に割り当てられたメモリを解放します。

- sbrk

ヒープ領域のブレーク値を加算して変更。
指定したブレーク値が現在のブレーク値より大きい場合には、ヒープ領域にメモリを割り当て。
指定したブレーク値が現在のブレーク値より小さい場合には、ヒープ領域に動的に割り当てられたメモリを解放します。

### ヒープメモリ

ユーザーコードから扱いやすい形式で適切にメモリを確保したり解放したりするのはランタイムの仕事。

OS内部でのメモリ確保はコストのかかる処理。 
物理メモリが足りない場合

- 優先度の低いメモリ領域を選ぶ
- HDDなどのストレージにスワップアウト
- 上記でも足りないときは他のプロセスを強制終了
    - LinuxのOOMキラーさせる

よって、ステムコールを使って比較的大きめのメモリブロックをOSからもらっておき、細かいメモリのやりくりは効率よくユーザーランドの中で行って、不要になったらOSにまるごと返却。

使うメモリ領域としては、ヒープとスタックの2種類がある。

C言語でメモリ確保に使う有名な標準関数は`malloc`。
容量を指定するとそのサイズのメモリブロックが確保し、ポンタを返却する。
Go言語ではTCMalloc(Google製)を採用している。

TCMallocの特徴
- 32キロバイト以下の小さなオブジェクトについては、スレッドごとにメモリブロックを管理する。これにより、ロックなどのスレッド競合によるパフォーマンス劣化を防ぐ
- 32キロバイトよりも大きなオブジェクトについては、4キロバイト単位に丸め、共有の中央ページヒープで管理してメモリの無駄を減らす

### スタック

関数を呼ぶと、リターンアドレスや新しい関数のための作業メモリ領域を含むスタックフレームと呼ばれるメモリブロックが確保される。
スレッドごとにあらかじめ確保されているメモリブロックに対して順番に追加したり削除したりされるだけなので、割当のコストはほぼゼロ。

デフォルトのスタックメモリのサイズは、Linuxではulimit -sで設定。

Go言語のgoroutineでは、最初は4キロバイトの小さなサイズのスタックを確保。
関数呼び出しで大きなサイズが必要なことがわかれば、別にスタックフレームを準備。

### ユーザーコード

Go言語では、構造体やプリミティブの初期化の方法がいくつか提供されている。
varで定義するときは型を明示。
`:=` と書くことで変数宣言と代入を同時に行える。

これらは`メモリを確保する`ことをコンパイラやランタイムに指示している。

C/C++はポインタを使わずにローカル変数として宣言するとスタックにメモリが確保され、newやmalloc()を使うとヒープメモリにメモリが確保、という仕組み。 

Go言語の場合どちらに置くかはコンパイラが自動的に判断。

コンパイラが賢いのでヌルポインタでランタイムエラーにならない。

golangではメモリがスタックとヒープのどちらに確保されているかは、ビルド時に`-gcflags -m`を渡すと表示される。

スタックのほうが高速なので、デフォルトではスタックを選択する。
外部の関数に渡したり返り値で使おうとしたりすると、宣言した関数のスコープよりも変数の寿命が長くなる可能性があるため、ヒープに逃がす(escape)。
(fmt.Printlnのような表示しか行わずデータを変更しない関数でもヒープにされる)

C/C++では、ヒープの場合はdeleteやfree()で明示的に削除したり、あるいはスマートポインタで削除されるように仕向ける必要がある。
Go言語ではコンパイラが安全側に倒しながら判断するため、どちらに置くかはプログラマーが意識する必要がない。
しかし、ヒープであってもスタックと同じように不要になったら自動で解放するガベージコレクタが不可欠。

### 仮想メモリが実現する高度な機能

`デマンドページング`
メモリを確保したと見せかけて、はじめてアクセスがあったときに実際に取得しにいくという仕組。
メモリを確保しても実際に使うまでにはタイムラグがあるので、
デマンドページングによって初期化コストが削れ、使用メモリのピークが異なるプロセス同士でうまくメモリを融通しやすくなる。

共有ライブラリ

仮想メモリには、複数のプロセスでシステムの同じ共有ライブラリをロードしている場合にメモリ消費を抑える仕組みもある。
それぞれのプロセスの仮想メモリには同じライブラリが個別にロードされているように見るが、ページテーブルを使って同じアドレスを参照している。これにより、1つ分のメモリしか消費しない。
