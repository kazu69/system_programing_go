## TCP Socket and HTTP

### プロトコルとレイヤー

Goでは`http`、``tcp`、`udp` についての組込機能が提供されている。

### HTTPとその上のプロトコル

#### HTTPの基本

HTTPでは、クライアントからのリクエストと、
それに対するサーバのレスポンスが規定されている。

```
メソッド パス HTTP/1.0
ヘッダ1: ヘッダーの値
ヘッダ2: ヘッダーの値
(空行)
リクエストボディ（あれば）
```

改行を区切り文字と決めている。

リクエスを受け取ると、以下の形式のレスポンスとして返す。

```
HTTP/1.0 200 OK
ヘッダ1: ヘッダーの値
ヘッダ2: ヘッダーの値
(空行)
サーバレスポンス
```

用途が広がったことでHTTPに対して要求される機能も増えた。
HTTP/2では通信内容がバイナリ化されて高速化。

#### RPC

RPC(Remote Procedure Calling)は、サーバが用意している機能を、
ローカルコンピュータ上にある関数のように簡単に呼び出そうとする仕組み。

- XML-RPC
- JSON-RPC

JSON-RPCの例

```
// 送信側
{"jsonrpc": "2.0", "method": "subtract", "params": [42, 23], "id": 1}
// 受信側
{"jsonrpc": "2.0", "result": 19, "id": 1}
```

#### REST

すべてを階層化されたリソース(ファイルのようなもの)とみなし、
URLを使ってそれらのリソースを取得したり投稿したりする。
このような考え方は、REST(Representational State Transfer)と呼ばれる。

RESTはHTTPのルールを最大限取り入れたプロトコル。
RESTの思想にしたがうシステムのことをRESTful。
HTTPレスポンスに`link`を入れ、そこからクライアントが自律的にデータ探索をし、リソースにアクセスする仕組みを`HATEOAS`。

HATEOASの原則に従ったAPI（例 github)。

#### GraphQL

Facabookが提唱するRPCベースのプロトコル。
GraphQLは複数の属性から構成されている要素を取得するためのクエリー言語。

### ソケットとは

ほとんどのOSではアプリケーション層からトランスポート層のプロトコルを利用するとき、
APIとしてソケットを利用

ブラウザを利用したHTTP通信は、サーバのTCPポート80番に対し、ソケットを使ったプロセス間通信を行います。

### ソケット通信の基本構造

net.Connを使って、HTTPによる通信。
Goの場合、サーバは`Listen()`、クライアントは`Dial()`というAPIの命名ルールがある。

クライアント

```golang
conn, err := net.Dial("tcp", "localhost:8080")
if err != nil {
  panic(err)
}
```

サーバー側

```golang
ln, err := net.Listen("tcp", ":8080")
if err != nil {
  panic(err)
}
conn, err := ln.Accept()
if err != nil {
  // handle error
}
```

1つのリクエストの処理中も他のリクエストを受け付けたり、
CPUが許す限り並列でタスクをこなしたりするためには

```golang
ln, err := net.Listen("tcp", ":8080")
if err != nil {
  panic(err)
}
// 一度で終了しないためにAccept()を何度も繰り返し呼ぶ
for {
  conn, err := ln.Accept()
  if err != nil {
    // handle error
  }
  // 1リクエスト処理中に他のリクエストのAccept()が行えるように
  // Goroutineを使って非同期にレスポンスを処理する
  go func() {
    // connを使った読み書き
  }()
}
```

#### Go言語でHTTPサーバを実装する

実際にGo言語でHTTPのコードを作成するときは、net/http以下のAPIを使う。

HTTP/1.1のKeep-Aliveに対応させる。
HTTP/1.1ではKeep-Aliveが規格に入った。
HTTP/1.0のように1つのメッセージごとに切断するのではなく、しばらくの間はTCP接続のセッションを維持して使いまわせる。

```
Keep-Aliveを使うことで、HTTP/1.0のように1つのメッセージごとに切断するのでなく、しばらくの間はTCP接続のセッションを維持して使いまわします。 TCPでは、セションを接続するのに1.5 RTT（ラウンドトリップタイム：1往復の通信で1RTT）の時がかかります。切断にも1.5 RTTの時間がかかります。 物理的な距離や回線速度など1 RTTの時間は変わりますが、RTTが多ければ通信速度に直接の影響を与えます。 一の送信（送信と確認の返信で1 RTT）につき1.5 + 1.5 = 3 RTTのオーバーヘッドがれば、実行速度は単純に1/4です。
```

#### 圧縮
圧縮をしてもパケット伝達の速度は変わらない。
転送を開始してから終了するまでの時間は短くなる。

#### チャンク形式のボディ
必要な情報をすべて一回で送ると全部のデータが用意できるまでレスポンスのスタート遅れる。

巨大なファイルを返すときに全体がメモリにロードされ、多大なリソースが必要。
httpではチャンク形式のレスポンスをサポートすることで、これらの問題に対処してる。
チャンク形式ではヘッダーに送信データのサイズを書かずに、`Transfer-Encoding:chunked`というヘッダーを付与。

チャンク形式であれば、準備ができた部分からレスポンスを開始できるため、レスポンの初動が早くなる。
データ全体を保持のためにメモリを確保するオーバーヘッドも減らせる。 
ヘッダーにサイズを入れる必要もなく、最終的なデータのサイズが決まる前に送信を開可能。

#### パイプライニング

レスポンスがくる前にリクエストを多重で飛ばすことで、最終的に通信が完了するまでの時間を短くする。
 
後方互換性がないため、HTTP/1.0しか解釈できないプロキシが途中にあると通信が完了
なくなる問題。

#### パイプライニングとhttp2

http/2では通信をバイナリ化(フレーム)にして送っている。
http/2ではヘッダーも圧縮できる。
httpでのリクエストはhttp2でのストリームとして扱われる。
TCPソケット的にはフレーム。
http/2では順序の保証が不要になったのでコンテンツをサーバーから送ることも可能。
サンプルコードでhttp/2っぽい非同期通信は可能。

http2実装には
https://godoc.org/golang.org/x/net/http2 がある

